<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>请我的暄暄小朋友接受礼物</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
  
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            sweet1: '#F9A8D4',
            sweet2: '#C084FC',
            sweet3: '#F472B6',
          },
          fontFamily: {
            cute: ['"Comic Sans MS"', 'sans-serif']
          }
        }
      }
    }
  </script>
  
  <style type="text/tailwindcss">
    @layer utilities {
      .btn-gradient {
        background: linear-gradient(135deg, #C084FC 0%, #F472B6 100%);
        box-shadow: 0 10px 25px -5px rgba(244, 114, 182, 0.5), 0 8px 10px -6px rgba(192, 132, 252, 0.3);
        transition: all 0.3s ease;
      }
      .btn-gradient:hover {
        box-shadow: 0 15px 30px -5px rgba(244, 114, 182, 0.7), 0 10px 15px -6px rgba(192, 132, 252, 0.5);
        transform: translateY(-3px);
      }
      .danmu {
        position: absolute;
        background: white;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        z-index: 10;
        animation: popIn 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        opacity: 0;
        transform: scale(0);
        min-width: 180px;
        max-width: 80%;
      }
      .danmu-header {
        background: linear-gradient(135deg, #C084FC 0%, #F472B6 100%);
        padding: 0.3rem 0.8rem;
        border-radius: 8px 8px 0 0;
        display: flex;
        align-items: center;
        gap: 0.3rem;
      }
      .danmu-dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: white;
      }
      .danmu-title {
        color: white;
        font-size: 0.8rem;
        font-weight: bold;
        flex: 1;
        text-align: center;
      }
      .danmu-content {
        padding: clamp(0.5rem, 2vw, 0.8rem) clamp(0.8rem, 3vw, 1.2rem);
        color: #333;
        font-family: 'Comic Sans MS', sans-serif;
        font-size: clamp(0.8rem, 2.5vw, 1rem);
        text-align: center;
        white-space: normal;
        word-wrap: break-word;
      }
      @keyframes popIn {
        0% { opacity: 0; transform: scale(0); }
        70% { transform: scale(1.1); }
        100% { opacity: 1; transform: scale(1); }
      }
      .big-danmu {
        font-size: clamp(1rem, 3.5vw, 1.6rem) !important;
        font-weight: bold;
        padding: clamp(0.6rem, 2.5vw, 0.9rem) clamp(1rem, 4vw, 1.8rem);
        z-index: 15;
      }
      .bg-heart {
        position: absolute;
        color: rgba(255, 255, 255, 0.6);
        font-size: clamp(0.375rem, 1.5vw, 1.125rem);
        animation: floatHeart 6s linear infinite;
        opacity: 0;
      }
      @keyframes floatHeart {
        0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
        10% { opacity: 0.6; }
        90% { opacity: 0.6; }
        100% { transform: translateY(-20vh) rotate(360deg); opacity: 0; }
      }
      .bg-star {
        position: absolute;
        color: rgba(255, 255, 255, 0.8);
        font-size: clamp(0.1875rem, 1vw, 0.625rem);
        animation: twinkle 2.5s ease-in-out infinite;
      }
      @keyframes twinkle {
        0%, 100% { opacity: 0.3; transform: scale(0.8); }
        50% { opacity: 1; transform: scale(1.2); }
      }
      .bg-bubble {
        position: absolute;
        border: 2px solid rgba(255, 255, 255, 0.5);
        border-radius: 50%;
        animation: riseBubble 8s linear infinite;
        opacity: 0;
      }
      @keyframes riseBubble {
        0% { transform: translateY(100vh) scale(0.5); opacity: 0; }
        10% { opacity: 0.5; }
        90% { opacity: 0.5; }
        100% { transform: translateY(-20vh) scale(1.2); opacity: 0; }
      }
      /* 立体爱心粒子效果 */
      .particle-heart {
        position: absolute;
        color: rgba(244, 114, 182, 0.8);
        font-size: clamp(0.5rem, 2vw, 1.5rem);
        transform-origin: center;
        animation: float3DHeart var(--duration, 8s) var(--easing, ease-in-out) var(--delay, 0s) infinite;
        filter: drop-shadow(0 0 10px rgba(244, 114, 182, 0.7));
        opacity: var(--opacity, 0.8);
      }
      @keyframes float3DHeart {
        0%, 100% {
          transform: translateY(0) translateX(0) rotate(0deg) scale(1);
          opacity: 0;
        }
        10%, 90% {
          opacity: var(--opacity, 0.8);
        }
        25% {
          transform: translateY(calc(var(--height, -10vh))) translateX(calc(var(--x-offset, 5vw) * var(--direction, 1))) rotate(calc(var(--rotation, 30deg) * var(--direction, 1))) scale(var(--scale, 1.2));
        }
        75% {
          transform: translateY(calc(var(--height, -10vh) * 0.7)) translateX(calc(var(--x-offset, 5vw) * var(--direction, 1) * -1)) rotate(calc(var(--rotation, 30deg) * var(--direction, 1) * -1)) scale(var(--scale, 1.1));
        }
      }
    }
  </style>
</head>

<body class="bg-black min-h-screen overflow-hidden">
  <div id="start" class="w-full h-screen relative p-4 overflow-hidden bg-black">
    <!-- 星星背景容器 -->
    <div id="stars-container" class="absolute inset-0 z-0"></div>
    
    <!-- 粒子背景容器 -->
    <div id="particle-container" class="absolute inset-0 z-0"></div>
    
    <!-- 中央爱心粒子效果 -->
    <div id="center-heart" class="absolute inset-0 flex flex-col items-center justify-center z-10">
      <div id="heart-particles" class="relative w-[clamp(150px,50vw,300px)] h-[clamp(150px,50vw,300px)]"></div>
      
      <!-- 文字效果 - 冬至快乐 -->
      <div class="text-white mt-6 text-[clamp(1.2rem,5vw,2.5rem)] font-bold tracking-wider text-center z-10">
        冬至快乐
        <i class="fa fa-snowflake-o ml-2 text-blue-300 animate-pulse"></i>
      </div>
      
      <!-- 文字效果 - 愿温暖常伴 -->
      <div class="text-pink-200 text-[clamp(0.9rem,3vw,1.5rem)] mt-2 text-center z-10">
        愿温暖常伴
      </div>
    </div>
    
    <!-- 按钮位置调整到爱心右侧下方 -->
    <button id="open" class="absolute bottom-[clamp(10vh,20vh,15vh)] right-[clamp(10vw,20vw,15vw)] z-20 
      btn-gradient text-white 
      text-[clamp(0.75rem,2.5vw,1.1rem)] 
      px-[clamp(1.5rem,6vw,3rem)] 
      py-[clamp(0.8rem,3vw,1.5rem)] 
      rounded-full hover:scale-105 transition-all font-cute">
      请我的暄暄小朋友接受礼物
    </button>
    
    <!-- 背景音乐元素 -->
    <audio id="backgroundMusic" loop>
      <source src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-1.mp3" type="audio/mpeg">
    </audio>
  </div>
  
  <div id="main" class="w-full h-screen 
    bg-gradient-to-br from-sweet2/90 to-sweet1/90 
    hidden relative overflow-hidden">
    <div id="bg-decor" class="absolute inset-0"></div>
    <div id="danmu-container" class="absolute inset-0"></div>
  </div>

  <script>
    const texts = [
      "暄暄老婆万圣节快乐",
      "老婆奖励我一个亲亲",
      "老婆辛苦啦早点休息",
      "老婆你还有我呢不要再伤害自己了",
      "老婆我们马上就要见面啦",
      "祝老婆学业顺利",
      "暄暄老婆冬至快乐"
    ];
    
    const colors = [
      '#F472B6', '#EC4899', '#C084FC', '#A78BFA', 
      '#F9A8D4', '#FB7185', '#F43F5E', '#8B5CF6'
    ];
    
    let danmuTimer = null; // 弹幕循环定时器，用于后续清除
    
    window.onload = () => {
      createStartDecor();
      
      document.getElementById('open').addEventListener('click', () => {
      document.getElementById('start').classList.add('hidden');
      const mainPage = document.getElementById('main');
      mainPage.classList.remove('hidden');
      createSweetBg();
      startLoopDanmus(); // 启动弹幕循环生成
      
      // 播放背景音乐
      const music = document.getElementById('backgroundMusic');
      music.play().catch(error => {
        console.log('背景音乐播放需要用户交互，将尝试通过交互事件播放:', error);
        // 尝试通过用户交互再次播放
        const playAudio = () => {
          music.play();
          document.removeEventListener('click', playAudio);
          document.removeEventListener('touchstart', playAudio);
        };
        document.addEventListener('click', playAudio);
        document.addEventListener('touchstart', playAudio);
      });
    });
      
      // 页面切换回开始页时，清除定时器（避免后台生成）
      window.addEventListener('visibilitychange', () => {
        if (document.hidden && danmuTimer) {
          clearInterval(danmuTimer);
          danmuTimer = null;
        } else if (!document.hidden && !danmuTimer && !document.getElementById('main').classList.contains('hidden')) {
          startLoopDanmus();
        }
      });
    };
    
    function createStartDecor() {
      // 创建星星背景
      createStarsBackground();
      // 创建立体爱心粒子背景
      createParticleHearts();
      // 创建中央动态粒子爱心
      createCentralHeartParticles();
    }
    
    function createStarsBackground() {
      const container = document.getElementById('stars-container');
      const starCount = window.innerWidth < 768 ? 150 : 300;
      
      for (let i = 0; i < starCount; i++) {
        const star = document.createElement('i');
        
        // 随机大小
        const size = Math.random() * 2 + 1;
        
        // 随机位置
        const left = Math.random() * 100;
        const top = Math.random() * 100;
        
        // 随机动画延迟
        const delay = Math.random() * 3;
        
        // 随机不透明度
        const opacity = Math.random() * 0.8 + 0.2;
        
        // 设置样式
        star.className = 'fa fa-star absolute';
        star.style.fontSize = `${size}px`;
        star.style.left = `${left}%`;
        star.style.top = `${top}%`;
        star.style.color = 'white';
        star.style.opacity = opacity;
        star.style.animation = `twinkle ${Math.random() * 2 + 1}s ease-in-out ${delay}s infinite`;
        
        container.appendChild(star);
      }
    }
    
    function createCentralHeartParticles() {
      const container = document.getElementById('heart-particles');
      const particleCount = window.innerWidth < 768 ? 200 : 300; // 粒子数量
      
      // 创建粒子数组
      const particles = [];
      
      // 爱心形状的参数
      const heartWidth = container.offsetWidth;
      const heartHeight = container.offsetHeight;
      const centerX = heartWidth / 2;
      const centerY = heartHeight / 2;
      const scale = Math.min(heartWidth, heartHeight) / 100;
      
      // 创建粒子
      for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('span');
        
        // 随机生成爱心形状内的点
        let x, y;
        do {
          // 使用参数方程生成爱心形状的点
          const t = Math.random() * Math.PI * 2;
          x = 16 * Math.pow(Math.sin(t), 3);
          y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
          
          // 缩放并偏移到容器中心
          x = centerX + x * scale * (0.8 + Math.random() * 0.2);
          y = centerY - y * scale * (0.8 + Math.random() * 0.2);
        } while (x < 0 || x > heartWidth || y < 0 || y > heartHeight);
        
        // 设置粒子样式
        particle.className = 'absolute inline-block';
        particle.style.width = `${2 + Math.random() * 3}px`;
        particle.style.height = `${2 + Math.random() * 3}px`;
        particle.style.backgroundColor = `rgba(${255}, ${Math.floor(Math.random() * 100) + 155}, ${Math.floor(Math.random() * 150) + 105}, ${0.7 + Math.random() * 0.3})`;
        particle.style.borderRadius = '50%';
        particle.style.left = `${x}px`;
        particle.style.top = `${y}px`;
        particle.style.transform = 'translate(-50%, -50%)';
        
        // 添加到容器
        container.appendChild(particle);
        
        // 存储粒子信息
        particles.push({
          element: particle,
          x: x,
          y: y,
          targetX: x,
          targetY: y,
          dx: (Math.random() - 0.5) * 0.5,
          dy: (Math.random() - 0.5) * 0.5,
          updateInterval: Math.random() * 2000 + 1000, // 1-3秒更新一次目标位置
          lastUpdate: 0
        });
      }
      
      // 动画更新函数
      function updateParticles(timestamp) {
        particles.forEach(particle => {
          // 随机改变粒子目标位置
          if (timestamp - particle.lastUpdate > particle.updateInterval) {
            // 计算一个在原位置附近的新目标位置
            const angle = Math.random() * Math.PI * 2;
            const distance = Math.random() * 15 + 5;
            
            // 确保新位置仍在爱心形状内
            let newX = particle.x + Math.cos(angle) * distance;
            let newY = particle.y + Math.sin(angle) * distance;
            
            // 边界检查
            newX = Math.max(10, Math.min(heartWidth - 10, newX));
            newY = Math.max(10, Math.min(heartHeight - 10, newY));
            
            particle.targetX = newX;
            particle.targetY = newY;
            particle.lastUpdate = timestamp;
          }
          
          // 向目标位置移动
          const speed = 0.01;
          particle.x += (particle.targetX - particle.x) * speed;
          particle.y += (particle.targetY - particle.y) * speed;
          
          // 更新粒子位置
          particle.element.style.left = `${particle.x}px`;
          particle.element.style.top = `${particle.y}px`;
        });
        
        // 继续动画
        requestAnimationFrame(updateParticles);
      }
      
      // 启动动画
      requestAnimationFrame(updateParticles);
      
      // 添加一些亮点效果
      function addSparkles() {
        const sparklesCount = Math.floor(particleCount * 0.1); // 10%的粒子作为亮点
        
        setInterval(() => {
          for (let i = 0; i < sparklesCount; i++) {
            const randomIndex = Math.floor(Math.random() * particles.length);
            const sparkle = particles[randomIndex];
            
            // 添加闪烁效果
            sparkle.element.style.transition = 'opacity 0.5s ease';
            sparkle.element.style.opacity = '1';
            sparkle.element.style.boxShadow = '0 0 10px 2px rgba(255, 255, 255, 0.8)';
            
            setTimeout(() => {
              sparkle.element.style.opacity = '';
              sparkle.element.style.boxShadow = '';
            }, 500);
          }
        }, 1000);
      }
      
      addSparkles();
    }
    
    function createParticleHearts() {
      const container = document.getElementById('particle-container');
      const count = window.innerWidth < 768 ? 30 : 50; // 增加粒子数量
      
      for (let i = 0; i < count; i++) {
        const heart = document.createElement('i');
        heart.className = 'fa fa-heart particle-heart';
        
        // 随机位置
        heart.style.left = `${Math.random() * 100}%`;
        heart.style.top = `${Math.random() * 100}%`;
        
        // 随机动画参数
        const duration = 5 + Math.random() * 10; // 5-15秒
        const height = -20 - Math.random() * 40; // -20vh 到 -60vh
        const xOffset = 5 + Math.random() * 15; // 5vw 到 20vw
        const rotation = 20 + Math.random() * 40; // 20deg 到 60deg
        const scale = 0.8 + Math.random() * 0.6; // 0.8 到 1.4
        const opacity = 0.4 + Math.random() * 0.6; // 0.4 到 1
        const delay = Math.random() * 5; // 0-5秒延迟
        const direction = Math.random() > 0.5 ? 1 : -1; // 方向
        
        // 设置CSS变量
        heart.style.setProperty('--duration', `${duration}s`);
        heart.style.setProperty('--height', `${height}vh`);
        heart.style.setProperty('--x-offset', `${xOffset}vw`);
        heart.style.setProperty('--rotation', `${rotation}deg`);
        heart.style.setProperty('--scale', scale);
        heart.style.setProperty('--opacity', opacity);
        heart.style.setProperty('--delay', `${delay}s`);
        heart.style.setProperty('--direction', direction);
        heart.style.setProperty('--easing', 'cubic-bezier(0.34, 1.56, 0.64, 1)');
        
        container.appendChild(heart);
      }
    }
    
    function createSweetBg() {
      const bgBox = document.getElementById('bg-decor');
      const isMobile = window.innerWidth < 768;
      
      const heartCount = isMobile ? 12 : 20;
      for (let i = 0; i < heartCount; i++) {
        const heart = document.createElement('i');
        heart.className = 'fa fa-heart bg-heart';
        heart.style.left = `${Math.random() * 100}%`;
        heart.style.animationDelay = `${Math.random() * 6}s`;
        bgBox.appendChild(heart);
      }
      
      const starCount = isMobile ? 18 : 30;
      for (let i = 0; i < starCount; i++) {
        const star = document.createElement('i');
        star.className = 'fa fa-star bg-star';
        star.style.left = `${Math.random() * 100}%`;
        star.style.top = `${Math.random() * 100}%`;
        star.style.animationDelay = `${Math.random() * 3}s`;
        bgBox.appendChild(star);
      }
      
      const bubbleCount = isMobile ? 8 : 15;
      for (let i = 0; i < bubbleCount; i++) {
        const bubble = document.createElement('div');
        bubble.className = 'bg-bubble';
        const size = isMobile ? Math.random() * 25 + 15 : Math.random() * 40 + 20;
        bubble.style.width = `${size}px`;
        bubble.style.height = `${size}px`;
        bubble.style.left = `${Math.random() * 100}%`;
        bubble.style.animationDelay = `${Math.random() * 8}s`;
        bgBox.appendChild(bubble);
      }
    }
    
    // 核心：启动弹幕循环生成（不断放入）
    function startLoopDanmus() {
      const danmuBox = document.getElementById('danmu-container');
      const isMobile = window.innerWidth < 768;
      const batchSize = isMobile ? 8 : 12; // 每批生成数量：手机8个，桌面12个
      const loopTime = 2000; // 每2秒生成一批（可调整速度）
      
      // 先清除旧定时器，避免重复
      if (danmuTimer) clearInterval(danmuTimer);
      
      // 循环生成函数
      function generateBatch() {
        for (let i = 0; i < batchSize; i++) {
          const danmu = document.createElement('div');
          danmu.className = 'danmu';
          
          const text = texts[Math.floor(Math.random() * texts.length)];
          
          const isMobile = window.innerWidth < 768;
          
          // 调整弹幕整体靠左显示，左侧不留空间
          let left, top;
          if (isMobile) {
            // 移动设备上从左侧开始，留出右侧适当空间
            left = 0 + Math.random() * 65; // 0% ≤ 左边位置 ≤ 65%
          } else {
            // 桌面设备同样从左侧开始
            left = 0 + Math.random() * 75; // 0% ≤ 左边位置 ≤ 75%
          }
          // 垂直方向保持使用整个屏幕高度
          top = Math.random() * 95;
          
          const delay = Math.random() * 0.8; // 每批内弹幕延迟弹出，更自然
          
          danmu.style.left = `${left}%`;
          danmu.style.top = `${top}%`;
          danmu.style.animationDelay = `${delay}s`;
          
          // 创建卡片内部结构
          danmu.innerHTML = `
            <div class="danmu-header">
              <span class="danmu-dot"></span>
              <span class="danmu-dot"></span>
              <span class="danmu-dot"></span>
              <span class="danmu-title">温馨提示</span>
              <span class="danmu-dot"></span>
              <span class="danmu-dot"></span>
              <span class="danmu-dot"></span>
            </div>
            <div class="danmu-content">${text}</div>
          `;
          
          // 针对移动设备的特殊样式调整
          if (isMobile) {
            // 移动设备上减小最小宽度，增加最大宽度限制
            danmu.style.minWidth = '140px';
            danmu.style.maxWidth = '70%';
            // 确保文本内容居中且不会溢出
            danmu.querySelector('.danmu-content').style.fontSize = 'clamp(0.75rem, 2.5vw, 0.9rem)';
          }
          
          // 移除特殊处理，所有弹幕保持一致大小
          // 这样可以确保所有弹幕都能正常显示，不会有特别大的弹幕遮挡其他内容
          
          danmuBox.appendChild(danmu);
          
          // 自动清除旧弹幕：10秒后消失（避免堆积卡顿）
          setTimeout(() => {
            // 消失动画：渐变透明+缩小
            danmu.style.transition = 'opacity 0.5s, transform 0.5s';
            danmu.style.opacity = 0;
            danmu.style.transform = 'scale(0.8)';
            // 完全透明后移除元素
            setTimeout(() => danmu.remove(), 500);
          }, 10000);
        }
      }
      
      // 立即生成第一批，然后每loopTime毫秒生成一批
      generateBatch();
      danmuTimer = setInterval(generateBatch, loopTime);
    }
  </script>
</body>
</html>