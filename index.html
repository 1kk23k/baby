<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="format-detection" content="telephone=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta property="og:type" content="website">
  <meta property="og:title" content="请我的暄暄小朋友接受礼物">
  <meta property="og:description" content="送给暄暄的特别礼物">
  <title>请我的暄暄小朋友接受礼物</title>
  <!-- 使用内联Tailwind CSS替代CDN，确保GitHub Pages可访问 -->
  <style>
    /* 基础样式 - 移除外部字体引用 */
    
    :root {
      --sweet1: #F9A8D4;
      --sweet2: #C084FC;
      --sweet3: #F472B6;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
      background-color: black;
      min-height: 100vh;
      overflow: hidden;
    }
    
    .font-cute {
      font-family: 'Comic Sans MS', cursive, sans-serif;
    }
    
    /* 按钮样式 */
    .btn-gradient {
      background: linear-gradient(135deg, var(--sweet2) 0%, var(--sweet3) 100%);
      color: white;
      border: none;
      border-radius: 9999px;
      padding: clamp(0.8rem, 3vw, 1.5rem) clamp(1.5rem, 6vw, 3rem);
      font-size: clamp(0.75rem, 2.5vw, 1.1rem);
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 10px 25px -5px rgba(244, 114, 182, 0.5), 0 8px 10px -6px rgba(192, 132, 252, 0.3);
    }
    
    .btn-gradient:hover {
      box-shadow: 0 15px 30px -5px rgba(244, 114, 182, 0.7), 0 10px 15px -6px rgba(192, 132, 252, 0.5);
      transform: translateY(-3px);
    }
    
    .btn-gradient:active {
      transform: translateY(-1px);
    }
    
    /* 响应式布局 */
    .w-full {
      width: 100%;
    }
    
    .h-screen {
      height: 100vh;
    }
    
    .relative {
      position: relative;
    }
    
    .absolute {
      position: absolute;
    }
    
    .inset-0 {
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
    }
    
    .flex {
      display: flex;
    }
    
    .items-center {
      align-items: center;
    }
    
    .justify-center {
      justify-content: center;
    }
    
    .hidden {
      display: none;
    }
    
    .z-0 { z-index: 0; }
    .z-10 { z-index: 10; }
    .z-20 { z-index: 20; }
    
    /* 动画相关 */
    .transition-all {
      transition: all 0.3s ease;
    }
    
    /* 响应式辅助 */
      @media (max-width: 768px) {
        .w-64 {
          width: 16rem;
    }
        
        .h-48 {
          height: 12rem;
        }
      }
      
      @media (min-width: 769px) {
        .md\:w-80 {
          width: 20rem;
        }
        
        .md\:h-64 {
          height: 16rem;
        }
      }
      
      /* 补充缺失的关键样式 */
      .transform {
        transform: var(--transform, none);
      }
      
      .-translate-x-1/2 {
        --transform: translateX(-50%);
      }
      
      .translate-x-1/2 {
        --transform: translateX(50%);
      }
      
      .scale-105 {
        transform: scale(1.05);
      }
      
      .scale-110 {
        transform: scale(1.1);
      }
      
      .scale-150 {
        transform: scale(1.5);
      }
      
      .mx-auto {
        margin-left: auto;
        margin-right: auto;
      }
      
      .px-4 {
        padding-left: 1rem;
        padding-right: 1rem;
      }
      
      .py-2 {
        padding-top: 0.5rem;
        padding-bottom: 0.5rem;
      }
      
      .rounded-lg {
        border-radius: 0.5rem;
      }
      
      .rounded-full {
        border-radius: 9999px;
      }
      
      .text-white {
        color: white;
      }
      
      .text-pink-600 {
        color: #db2777;
      }
      
      .text-sm {
        font-size: 0.875rem;
      }
      
      .font-bold {
        font-weight: bold;
      }
      
      .shadow-lg {
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      }
      
      .shadow-md {
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      }
      
      .shadow-2xl {
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      }
      
      .backdrop-blur-sm {
        backdrop-filter: blur(4px);
        -webkit-backdrop-filter: blur(4px);
      }
      
      .bg-white/80 {
        background-color: rgba(255, 255, 255, 0.8);
      }
      
      .bg-black/50 {
        background-color: rgba(0, 0, 0, 0.5);
      }
    
    /* 自定义滚动条 */
    ::-webkit-scrollbar {
      display: none;
    }
    
    html {
      -ms-overflow-style: none;
      scrollbar-width: none;
    }
    
    /* 确保按钮在底部的位置 */
    .bottom-25vh {
      bottom: 25vh;
    }
  </style>
  
  <style>
        /* 按钮样式 - 覆盖前面的定义 */
        .btn-gradient {
          background: linear-gradient(135deg, #C084FC 0%, #F472B6 100%) !important;
          box-shadow: 0 10px 25px -5px rgba(244, 114, 182, 0.5), 0 8px 10px -6px rgba(192, 132, 252, 0.3) !important;
          transition: all 0.3s ease !important;
        }
        .btn-gradient:hover {
          box-shadow: 0 15px 30px -5px rgba(244, 114, 182, 0.7), 0 10px 15px -6px rgba(192, 132, 252, 0.5) !important;
          transform: translateY(-3px) !important;
        }
        
        /* 弹幕样式 */
        .danmu {
          position: absolute;
          background: white;
          border-radius: 8px;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
          z-index: 10;
          opacity: 0;
          transform: scale(0);
          min-width: 180px;
          max-width: 80%;
        }
        
        .danmu-header {
          background: linear-gradient(135deg, #C084FC 0%, #F472B6 100%);
          padding: 0.3rem 0.8rem;
          border-radius: 8px 8px 0 0;
          display: flex;
          align-items: center;
          gap: 0.3rem;
        }
        
        .danmu-dot {
          width: 6px;
          height: 6px;
          border-radius: 50%;
          background: white;
        }
        
        .danmu-title {
          color: white;
          font-size: 0.8rem;
          font-weight: bold;
          flex: 1;
          text-align: center;
        }
        
        .danmu-content {
          padding: clamp(0.5rem, 2vw, 0.8rem) clamp(0.8rem, 3vw, 1.2rem);
          color: #333;
          font-family: 'Comic Sans MS', sans-serif;
          font-size: clamp(0.8rem, 2.5vw, 1rem);
          text-align: center;
          white-space: normal;
          word-wrap: break-word;
        }
        
        /* 动画关键帧 */
        @keyframes popIn {
          0% { opacity: 0; transform: scale(0); }
          70% { transform: scale(1.1); }
          100% { opacity: 1; transform: scale(1); }
        }
        
        @keyframes floatHeart {
          0% { transform: translateY(100vh) rotate(0deg); opacity: 0; }
          10% { opacity: 0.6; }
          90% { opacity: 0.6; }
          100% { transform: translateY(-20vh) rotate(360deg); opacity: 0; }
        }
        
        @keyframes floatAround {
          0% { transform: translate(0, 0) rotate(0deg); opacity: 0; }
          20% { transform: translate(20px, -10px) rotate(10deg); opacity: 0.7; }
          40% { transform: translate(0px, -20px) rotate(0deg); opacity: 0.8; }
          60% { transform: translate(-20px, -30px) rotate(-10deg); opacity: 0.7; }
          80% { transform: translate(0px, -40px) rotate(0deg); opacity: 0.5; }
          100% { transform: translate(0px, -50px) rotate(5deg); opacity: 0; }
        }
        
        @keyframes twinkle {
          0%, 100% { opacity: 0.3; transform: scale(0.8); }
          50% { opacity: 1; transform: scale(1.5); }
        }
        
        @keyframes riseBubble {
          0% { transform: translateY(100vh) scale(0.5); opacity: 0; }
          10% { opacity: 0.5; }
          90% { opacity: 0.5; }
          100% { transform: translateY(-20vh) scale(1.2); opacity: 0; }
        }
        
        @keyframes float3DHeart {
          0%, 100% {
            transform: translateY(0) translateX(0) rotate(0deg) scale(1);
            opacity: 0;
          }
          10%, 90% {
            opacity: 0.8;
          }
          25% {
            transform: translateY(-10vh) translateX(5vw) rotate(30deg) scale(1.2);
          }
          75% {
            transform: translateY(-7vh) translateX(-5vw) rotate(-30deg) scale(1.1);
          }
        }
        
        @keyframes heartbeat {
          0%, 100% { transform: scale(1); }
          50% { transform: scale(1.5); }
        }
        
        @keyframes firework {
          0% {
            opacity: 1;
            transform: translateY(0) scale(1);
          }
          100% {
            opacity: 0;
            transform: translateY(-100vh) scale(0.3);
          }
        }
        
        /* 其他辅助样式 */
        .big-danmu {
          font-size: clamp(1rem, 3.5vw, 1.6rem) !important;
          font-weight: bold;
          padding: clamp(0.6rem, 2.5vw, 0.9rem) clamp(1rem, 4vw, 1.8rem);
          z-index: 15;
        }
        
        .bg-heart {
          position: absolute;
          color: rgba(255, 255, 255, 0.6);
          font-size: clamp(0.375rem, 1.5vw, 1.125rem);
          animation: floatHeart 6s linear infinite;
          opacity: 0;
        }
        
        .bg-heart-float {
          position: absolute;
          opacity: 0;
          animation: floatAround 8s ease-in-out infinite;
        }
        
        .bg-star {
          position: absolute;
          background-color: rgba(255, 255, 255, 0.9);
          border-radius: 50%;
          width: 1px;
          height: 1px;
          box-shadow: 0 0 1px 0.5px rgba(255, 255, 255, 0.7);
          animation: twinkle 2.5s ease-in-out infinite;
        }
        
        .bg-bubble {
          position: absolute;
          border: 2px solid rgba(255, 255, 255, 0.5);
          border-radius: 50%;
          animation: riseBubble 8s linear infinite;
          opacity: 0;
        }
        
        .particle-heart {
          position: absolute;
          color: rgba(244, 114, 182, 0.8);
          font-size: clamp(0.5rem, 2vw, 1.5rem);
          transform-origin: center;
          animation: float3DHeart 8s ease-in-out 0s infinite;
          filter: drop-shadow(0 0 10px rgba(244, 114, 182, 0.7));
          opacity: 0.8;
        }
        
        .heart-container {
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          z-index: 1;
        }
        
        .heart-container img {
          width: clamp(200px, 65vw, 450px);
          height: auto;
          filter: drop-shadow(0 0 30px #ff69b4);
          animation: heartbeat 2s ease-in-out infinite;
        }
        
        .text-particle {
          position: absolute;
          pointer-events: none;
          opacity: 0;
          will-change: transform, opacity;
          font-family: 'Microsoft YaHei', sans-serif;
          font-weight: bold;
          z-index: 2;
        }
  </style>
</head>

<body class="bg-black min-h-screen overflow-hidden">
  <div id="start" class="w-full h-screen relative p-4 overflow-hidden bg-black">
    <!-- 星星背景容器 -->
    <div id="stars-container" class="absolute inset-0 z-0"></div>
    
    <!-- 粒子背景容器 -->
    <div id="particle-container" class="absolute inset-0 z-0"></div>
    
    <!-- 中央爱心效果 - 添加错误处理 -->
      <div id="center-heart" class="heart-container absolute z-10">
        <img src="https://pic.imgdb.cn/item/642547f5a682492fcc15cd5d.gif" alt="爱心" onerror="this.onerror=null; this.src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cGF0aCBmaWxsPSIjZmY2OWI0IiBmaWxsLW9wYWNpdHk9IjAuOSIgZD0iTTUyIDM1IEMzOCAzNSAzMCA0MyAyNiA1NS41QzIyIDQzIDE0IDM1IDAgMzUgQzAgMzUgMTcgNDcgMjUgNjJDMzMgNzcgNDYgOTIgNTIgOTJDNTggOTIgNzEgNzcgNzkgNjJDODcgNDcgNzMgMzUgNTIgMzVaIj48L3BhdGg+PC9zdmc+';" />
      </div>
    
    <!-- 按钮位置调整到爱心下方 -->
    <button id="open" class="absolute top-[70vh] left-1/2 transform -translate-x-1/2 z-20 
      btn-gradient text-white 
      text-[clamp(0.75rem,2.5vw,1.1rem)] 
      px-[clamp(1.5rem,6vw,3rem)] 
      py-[clamp(0.8rem,3vw,1.5rem)] 
      rounded-full hover:scale-105 transition-all font-cute">
      请我的暄暄小朋友接受礼物
    </button>
    
    <!-- 背景音乐元素 - 使用相对路径并添加错误处理 -->
    <audio id="backgroundMusic">
      <source src="./2.m4a" type="audio/mp4">
    </audio>
    <!-- 长按播放的音乐元素 - 使用相对路径并添加错误处理 -->
    <audio id="heartMusic">
      <source src="./5.m4a" type="audio/mp4">
    </audio>
    
    <!-- 长按提示框 -->
    <div id="heartTip" class="absolute top-1/3 left-1/2 transform -translate-x-1/2 bg-white/80 backdrop-blur-sm px-4 py-2 rounded-lg text-pink-600 font-cute text-sm hidden z-20 shadow-lg">
      长按爱心播放音乐 ❤️
    </div>
  </div>
  
  <div id="main" class="w-full h-screen 
    bg-gradient-to-br from-sweet2/90 to-sweet1/90 
    hidden relative overflow-hidden">
      <div id="bg-decor" class="absolute inset-0"></div>
      <div id="danmu-container" class="absolute inset-0"></div>
      
      <!-- 照片滑动展示区域 -->
      <div id="photo-gallery" class="absolute inset-0 flex items-center justify-center px-0">
        <div id="photo-container" class="relative w-full h-[70vh] min-h-[450px] overflow-hidden">
          <div id="photo-slider" class="flex transition-transform duration-300 h-full">
          <!-- 照片将通过JS动态添加 -->
        </div>
        <!-- 左右界限指示器 -->
        <div id="left-bound" class="absolute left-0 top-0 bottom-0 w-1 bg-red-500 z-10 hidden"></div>
        <div id="right-bound" class="absolute right-0 top-0 bottom-0 w-1 bg-red-500 z-10 hidden"></div>
        <!-- 提示信息 -->
        <div id="swipe-hint" class="absolute bottom-4 left-1/2 transform -translate-x-1/2 bg-black/50 text-white px-4 py-2 rounded-lg text-sm z-20">
          左右滑动查看照片
        </div>
      </div>
    </div>
  </div>

  <script>
    // 设备性能检测
    let isLowEndDevice = false;
    // 检测设备性能，低端设备降低动画复杂度
    function checkDevicePerformance() {
      // 检测内存和CPU
      const memory = navigator.deviceMemory || 4;
      const cores = navigator.hardwareConcurrency || 4;
      const isMobile = window.innerWidth < 768;
      const isSlowMobile = isMobile && (memory < 3 || cores < 4);
      
      isLowEndDevice = isSlowMobile || 
                     (performance && performance.memory && performance.memory.jsHeapSizeLimit < 1073741824);
      
      if (isLowEndDevice) {
        console.log('检测到低端设备，降低动画复杂度');
      }
    }
    
    checkDevicePerformance();
    
    const texts = [
      "暄暄老婆万圣节快乐",
      "老婆奖励我一个亲亲",
      "老婆辛苦啦早点休息",
      "老婆你还有我呢不要再伤害自己了",
      "老婆我们马上就要见面啦",
      "祝老婆学业顺利",
      "暄暄老婆冬至快乐"
    ];
    
    const colors = [
      '#F472B6', '#EC4899', '#C084FC', '#A78BFA', 
      '#F9A8D4', '#FB7185', '#F43F5E', '#8B5CF6'
    ];
    
    let danmuTimer = null; // 弹幕循环定时器，用于后续清除
    
    window.onload = () => {
      init();
      
      // 点按爱心播放音乐功能
      const heartContainer = document.getElementById('center-heart');
      const heartMusic = document.getElementById('heartMusic');
      const heartTip = document.getElementById('heartTip');
      let isHeartMusicPlaying = false;
      let audioSupported = true;
      
      // 更新提示框文本
      if (heartTip) {
        heartTip.textContent = '点击爱心播放音乐 ❤️';
      }
      
      // 显示提示框
      heartContainer.addEventListener('mouseenter', () => {
        if (heartTip) {
          heartTip.classList.remove('hidden');
        }
      });
      
      // 隐藏提示框
      heartContainer.addEventListener('mouseleave', () => {
        if (heartTip) {
          heartTip.classList.add('hidden');
        }
      });
      
      // 添加点击事件播放音乐
      const playHeartMusic = () => {
        if (!isHeartMusicPlaying && audioSupported) {
          heartMusic.play().catch(error => {
            console.log('播放音乐失败:', error);
            // 如果第一次播放失败，禁用音频功能以避免后续错误
            if (!isHeartMusicPlaying) {
              audioSupported = false;
              // 可选：提示用户音频无法播放
              if (heartTip) {
                heartTip.textContent = '音频无法播放，继续欣赏动画吧 ❤️';
                setTimeout(() => {
                  if (heartTip) heartTip.textContent = '点击爱心播放音乐 ❤️';
                }, 3000);
              }
            }
          });
          isHeartMusicPlaying = true;
        }
      };
      
      // 鼠标点击事件
      heartContainer.addEventListener('click', playHeartMusic);
      
      // 触摸点击事件
      heartContainer.addEventListener('touchstart', (e) => {
        e.preventDefault();
        playHeartMusic();
      });
      
      document.getElementById('open').addEventListener('click', () => {
      document.getElementById('start').classList.add('hidden');
      const mainPage = document.getElementById('main');
      mainPage.classList.remove('hidden');
      
      // 确保main页面有背景色
      mainPage.style.background = 'linear-gradient(135deg, #F9A8D4 0%, #C084FC 100%)';
      
      // 使用增强的背景效果，确保与开始页面一致
      setTimeout(() => {
        createSweetBg();
      }, 100);
      
      // 使用防错处理初始化照片画廊
      try {
        initPhotoGallery(); 
      } catch (error) {
        console.log('照片画廊初始化失败:', error);
      }
      
      // 停止爱心音乐
      if (isHeartMusicPlaying) {
        heartMusic.pause();
        heartMusic.currentTime = 0;
        isHeartMusicPlaying = false;
      }
      
      // 播放背景音乐
      if (audioSupported) {
        const music = document.getElementById('backgroundMusic');
        music.play().catch(error => {
          console.log('背景音乐播放失败:', error);
          // 禁用音频功能以避免后续错误
          audioSupported = false;
        });
      }
      
      // 添加整个页面的点击弹幕事件
      const addGlobalDanmuEvent = () => {
        document.addEventListener('click', handleGlobalClick);
      };
      
      const handleGlobalClick = (e) => {
        // 获取点击位置（相对于视口）
        const clickX = e.clientX;
        const clickY = e.clientY;
        // 爆炸出弹幕
        explodeDanmuAtPosition(clickX, clickY);
      };
      
      // 添加全局点击事件
      addGlobalDanmuEvent();
    });
      
      // 页面切换回开始页时，清除定时器（避免后台生成）
      window.addEventListener('visibilitychange', () => {
        if (document.hidden && danmuTimer) {
          clearInterval(danmuTimer);
          danmuTimer = null;
        } else if (!document.hidden && !danmuTimer && !document.getElementById('main').classList.contains('hidden')) {
        // 页面可见时，可以在这里添加弹幕循环逻辑
      }
      });
    };
    
    // FireworkSystem类 - 实现文字粒子发射效果
    class FireworkSystem {
      constructor() {
        this.particles = [];
        this.texts = ['我爱你 暄暄', '请我的暄暄小朋友接受礼物', '我永远爱你', '你是我的唯一'];
        this.colors = ['#87CEFA', '#B0E0E6', '#ADD8E6', '#AFEEEE', '#F472B6', '#EC4899'];
        this.init();
      }

      init() {
        // 根据设备性能调整粒子池大小
        const poolSize = isLowEndDevice ? 100 : 200;
        this.createPool(poolSize);
        this.startLaunch();
        this.setupClick();
      }

      createPool(size) {
        const container = document.createElement('div');
        for (let i = 0; i < size; i++) {
          const p = document.createElement('div');
          p.className = 'text-particle';
          p.style.display = 'none';
          container.appendChild(p);
        }
        document.body.appendChild(container);
        this.pool = [...container.children];
      }

      getParticle() {
        return this.pool.find(p => p.style.display === 'none');
      }

      launch() {
        const particle = this.getParticle();
        if (!particle) return;

        // 粒子样式设置
        particle.textContent = this.texts[Math.floor(Math.random() * this.texts.length)];
        particle.style.color = this.colors[Math.floor(Math.random() * this.colors.length)];
        // 根据设备性能调整字体大小，减少渲染负担
        const fontSize = isLowEndDevice ? `${14 + Math.random() * 8}px` : `${18 + Math.random() * 12}px`;
        particle.style.fontSize = fontSize;
        particle.style.display = 'block';
        particle.style.opacity = '1';

        // 动画参数
        const startX = window.innerWidth * 0.5;
        const startY = window.innerHeight + 50;
        const angle = (Math.PI/2) + (Math.random() - 0.5) * Math.PI/2;
        // 低端设备缩短距离，减少计算量
        const distance = isLowEndDevice ? 300 + Math.random() * 200 : 500 + Math.random() * 300;
        // 低端设备加快动画速度
        const duration = isLowEndDevice ? 2 + Math.random() * 1.5 : 3 + Math.random() * 2;

        // 设置初始位置
        particle.style.transform = `translate(${startX}px, ${startY}px)`;

        // 创建动画
        const animation = particle.animate([
          { 
            transform: `translate(${startX}px, ${startY}px) scale(1)`,
            opacity: 1
          },
          {
            transform: `translate(${startX + Math.cos(angle) * distance}px, 
                       ${startY - Math.abs(Math.sin(angle) * distance * 1.5)}px) scale(0.5)`,
            opacity: 0
          }
        ], {
          duration: duration * 1000,
          easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
        });

        animation.onfinish = () => {
          particle.style.display = 'none';
        };
      }

      startLaunch() {
        // 控制发射频率，避免低端设备性能问题
        const interval = isLowEndDevice ? 200 : 100;
        let lastLaunchTime = 0;
        
        const launch = (timestamp) => {
          if (!lastLaunchTime || timestamp - lastLaunchTime > interval) {
            this.launch();
            lastLaunchTime = timestamp;
          }
          requestAnimationFrame(launch);
        };
        requestAnimationFrame(launch);
      }

      setupClick() {
        let lastClick = 0;
        document.addEventListener('click', (e) => {
          const now = Date.now();
          if (now - lastClick > 200) {
            // 根据设备性能调整点击时发射的粒子数量
            const particleCount = isLowEndDevice ? 15 : 30;
            for (let i = 0; i < particleCount; i++) {
              setTimeout(() => this.launch(), i * 50);
            }
            lastClick = now;
          }
        });
      }
    }
    
    function createStartDecor() {
      // 创建星星背景
      createStarsBackground();
      // 创建立体爱心粒子背景
      createParticleHearts();
    }
    
    function createStarsBackground() {
      const container = document.getElementById('stars-container');
      // 根据设备性能调整星星数量
      let starCount = window.innerWidth < 768 ? 300 : 500; // 默认数量大幅增加
      if (isLowEndDevice) {
        starCount = window.innerWidth < 768 ? 100 : 200; // 低端设备也增加星星数
      }
      
      for (let i = 0; i < starCount; i++) {
        const star = document.createElement('i');
        
        // 随机大小
        const size = Math.random() * 2 + 1;
        
        // 随机位置
        const left = Math.random() * 100;
        const top = Math.random() * 100;
        
        // 随机动画延迟
        const delay = Math.random() * 3;
        
        // 随机不透明度
        const opacity = Math.random() * 0.8 + 0.2;
        
        // 设置样式
        star.className = 'bg-star';
        star.style.width = `${size * 0.5}px`;
        star.style.height = `${size * 0.5}px`;
        star.style.left = `${left}%`;
        star.style.top = `${top}%`;
        star.style.opacity = opacity;
        star.style.animation = `twinkle ${Math.random() * 2 + 1}s ease-in-out ${delay}s infinite`;
        
        container.appendChild(star);
      }
    }
    
    function createParticleHearts() {
      const container = document.getElementById('particle-container');
      // 根据设备性能调整粒子数量，大幅增加数量
      let count = window.innerWidth < 768 ? 200 : 300; // 大幅增加默认数量
      if (isLowEndDevice) {
        count = window.innerWidth < 768 ? 100 : 150; // 低端设备也大幅增加粒子数
      }
      
      for (let i = 0; i < count; i++) {
        const heart = document.createElement('i');
        heart.className = 'fa fa-heart particle-heart';
        
        // 随机位置
        heart.style.left = `${Math.random() * 100}%`;
        heart.style.top = `${Math.random() * 100}%`;
        
        // 随机动画参数，减慢速度
        const duration = 4 + Math.random() * 6; // 4-10秒，减慢移动速度
        const height = -20 - Math.random() * 40; // 减少垂直移动距离
        const xOffset = 5 + Math.random() * 15; // 减少水平移动距离
        const rotation = 20 + Math.random() * 40; // 减少旋转角度
        const scale = 0.8 + Math.random() * 0.6; // 保持不变
        const opacity = 0.4 + Math.random() * 0.6; // 保持不变
        const delay = Math.random() * 3; // 0-3秒延迟，减慢生成速度
        const direction = Math.random() > 0.5 ? 1 : -1; // 方向
        
        // 设置CSS变量
        heart.style.setProperty('--duration', `${duration}s`);
        heart.style.setProperty('--height', `${height}vh`);
        heart.style.setProperty('--x-offset', `${xOffset}vw`);
        heart.style.setProperty('--rotation', `${rotation}deg`);
        heart.style.setProperty('--scale', scale);
        heart.style.setProperty('--opacity', opacity);
        heart.style.setProperty('--delay', `${delay}s`);
        heart.style.setProperty('--direction', direction);
        heart.style.setProperty('--easing', 'cubic-bezier(0.34, 1.56, 0.64, 1)');
        
        container.appendChild(heart);
      }
    }

    // 性能优化相关 - requestAnimationFrame 兼容性处理
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = function (callback, element) {
        let lastTime = 0;
        const currTime = new Date().getTime();
        const timeToCall = Math.max(0, 16 - (currTime - lastTime));
        const id = window.setTimeout(function () {
          callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
      };
    }

    // 页面隐藏时停止动画，提升性能
    let hiddenProperty = 'hidden' in document ? 'hidden' : 
      'webkitHidden' in document ? 'webkitHidden' :
      'mozHidden' in document ? 'mozHidden' :
      null;
    let visibilityChangeEvent = hiddenProperty.replace(/hidden/i, 'visibilitychange');

    document.addEventListener(visibilityChangeEvent, function() {
      if (!document[hiddenProperty]) {
        // 页面可见时，重新启动动画
        if (typeof fireworkSystem !== 'undefined') {
          fireworkSystem.startLaunch();
        }
      }
    });

    // 优化事件监听器
    function debounce(func, wait) {
      let timeout;
      return function() {
        const context = this, args = arguments;
        const later = function() {
          timeout = null;
          func.apply(context, args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // 窗口调整大小时重新计算星星背景
    window.addEventListener('resize', debounce(function() {
      const container = document.getElementById('stars-container');
      while (container.firstChild) {
        container.removeChild(container.firstChild);
      }
      createStarsBackground();
    }, 100));

    // 初始化变量
    let fireworkSystem;

    // 修改初始化函数，存储fireworkSystem实例
    function init() {
      // 初始化背景音乐
      if (typeof initMusic === 'function') {
        initMusic();
      }
      // 创建装饰效果
      createStartDecor();
      // 初始化烟花系统
      fireworkSystem = new FireworkSystem();
    }
    
    // 增强的背景创建函数，融合星星和爱心效果，与按钮界面保持一致
    function createSweetBg() {
      console.log('创建背景效果...');
      // 首先清空背景容器，避免重复添加
      const bgBox = document.getElementById('bg-decor');
      if (!bgBox) {
        console.error('未找到背景容器');
        return;
      }
      bgBox.innerHTML = '';
      
      // 获取星星和粒子容器
      const starsContainer = document.getElementById('stars-container');
      const particleContainer = document.getElementById('particle-container');
      
      if (!starsContainer || !particleContainer) {
        console.error('未找到星星或粒子容器');
        return;
      }
      
      // 清空现有内容
      starsContainer.innerHTML = '';
      particleContainer.innerHTML = '';
      
      // 创建立体爱心粒子背景，与开始页面完全一致
      createParticleHearts();
      
      // 创建星星背景
      createStarsBackground();
      
      // 额外添加更多飘动的爱心，增强背景效果
      const isMobile = window.innerWidth < 768;
      // 增加爱心数量，确保背景效果丰富
      const heartCount = isLowEndDevice ? (isMobile ? 150 : 300) : (isMobile ? 200 : 400);
      
      for (let i = 0; i < heartCount; i++) {
        // 创建爱心元素（使用文本而不是Font Awesome，确保兼容性）
        const heart = document.createElement('div');
        heart.innerHTML = '❤';
        heart.className = 'bg-heart-float';
        heart.style.position = 'absolute';
        heart.style.left = `${Math.random() * 100}%`;
        heart.style.top = `${Math.random() * 100}%`;
        heart.style.animationDelay = `${Math.random() * 15}s`;
        // 随机大小，增加变化范围
        const size = 8 + Math.random() * 20;
        heart.style.fontSize = `${size}px`;
        // 随机颜色，使用更多样的粉色系
        const colors = ['#F472B6', '#EC4899', '#C084FC', '#A78BFA', '#F9A8D4', '#FB7185', '#F43F5E'];
        heart.style.color = colors[Math.floor(Math.random() * colors.length)];
        // 添加随机透明度变化
        heart.style.opacity = 0.5 + Math.random() * 0.5;
        // 确保动画正常应用
        heart.style.animation = 'floatAround 8s ease-in-out infinite';
        heart.style.pointerEvents = 'none';
        heart.style.transformOrigin = 'center';
        bgBox.appendChild(heart);
      }
      
      // 添加额外的星星，增强闪烁效果
      addMoreStars();
    }
    
    // 添加更多星星效果
    function addMoreStars() {
      const container = document.getElementById('stars-container');
      const additionalStars = isLowEndDevice ? 200 : 400;
      
      for (let i = 0; i < additionalStars; i++) {
        const star = document.createElement('div');
        star.className = 'bg-star';
        
        // 随机大小
        const size = Math.random() * 3 + 1;
        
        // 随机位置
        const left = Math.random() * 100;
        const top = Math.random() * 100;
        
        // 随机动画延迟
        const delay = Math.random() * 5;
        
        // 随机不透明度
        const opacity = Math.random() * 0.8 + 0.2;
        
        // 设置样式
        star.style.width = `${size}px`;
        star.style.height = `${size}px`;
        star.style.left = `${left}%`;
        star.style.top = `${top}%`;
        star.style.opacity = opacity;
        star.style.animation = `twinkle ${Math.random() * 3 + 2}s ease-in-out ${delay}s infinite`;
        star.style.position = 'absolute';
        star.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
        star.style.borderRadius = '50%';
        star.style.boxShadow = '0 0 2px 1px rgba(255, 255, 255, 0.7)';
        
        container.appendChild(star);
      }
    }
    
    // 初始化照片画廊
    function initPhotoGallery() {
      const slider = document.getElementById('photo-slider');
      const container = document.getElementById('photo-container');
      const leftBound = document.getElementById('left-bound');
      const rightBound = document.getElementById('right-bound');
      const photos = ['./a.jpg', './b.jpg', './c.jpg', './d.jpg', './e.jpg', './f.jpg'];
      
      // 清空slider内容
      slider.innerHTML = '';
      
      // 设置slider样式
      slider.style.width = 'auto';
      slider.style.display = 'flex';
      slider.style.alignItems = 'center';
      
      // 创建胶卷容器
      const filmRoll = document.createElement('div');
      filmRoll.className = 'relative flex items-center';
      filmRoll.style.padding = '20px 40px';
      
      // 添加胶卷孔和边框效果
      const createFilmHoles = (parent, side) => {
        for (let i = 0; i < 8; i++) {
          const hole = document.createElement('div');
          hole.className = 'absolute bg-black rounded-full';
          hole.style.width = '12px';
          hole.style.height = '12px';
          hole.style.left = side === 'left' ? '10px' : 'calc(100% - 22px)';
          hole.style.top = `${30 + i * 30}px`;
          parent.appendChild(hole);
        }
      };
      
      // 创建温馨照片框架
      const createFilmFrame = (photoSrc, index) => {
        const frame = document.createElement('div');
        frame.className = 'relative inline-block mx-2';
        frame.style.margin = '0 8px';
        
        // 温馨胶卷框架HTML结构
        frame.innerHTML = `
          <div class="relative border-8 border-pink-200 bg-gradient-to-r from-pink-100 to-purple-100 p-1 transform transition-transform hover:scale-105 duration-300 shadow-xl">
            <!-- 照片容器 - 增大照片尺寸 -->
              <div class="relative w-64 h-48 md:w-80 md:h-64 overflow-hidden bg-white rounded-lg">
              <!-- 装饰元素 -->
              <div class="absolute -top-4 left-0 right-0 flex justify-between px-2">
                <div class="w-8 h-4 bg-pink-300 rounded-b-full"></div>
                <div class="w-8 h-4 bg-pink-300 rounded-b-full"></div>
              </div>
              <div class="absolute -bottom-4 left-0 right-0 flex justify-between px-2">
                <div class="w-8 h-4 bg-pink-300 rounded-t-full"></div>
                <div class="w-8 h-4 bg-pink-300 rounded-t-full"></div>
              </div>
              <!-- 装饰角落 -->
              <div class="absolute top-2 left-2 w-12 h-12 border-t-2 border-l-2 border-pink-400 rounded-tl-lg"></div>
              <div class="absolute top-2 right-2 w-12 h-12 border-t-2 border-r-2 border-pink-400 rounded-tr-lg"></div>
              <div class="absolute bottom-2 left-2 w-12 h-12 border-b-2 border-l-2 border-pink-400 rounded-bl-lg"></div>
              <div class="absolute bottom-2 right-2 w-12 h-12 border-b-2 border-r-2 border-pink-400 rounded-br-lg"></div>
              
              <!-- 照片元素 -->
              <img src="${photoSrc}" alt="照片 ${index + 1}" 
                   class="w-full h-full object-contain p-2" 
                   onload="this.style.opacity = '1'; this.style.transform = 'scale(1.05)';" 
                   onerror="this.src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48cGF0aCBkPSJNMjAgMjBjMC0xMS4wNCA4Ljk2LTIwIDIwLTIwczIwIDguOTYgMjAgMjBzLTguOTYgMjAtMjAgMjBzLTIwLTguOTYtMjAtMjB6bTUwIDBIMjB2NjBoNTB2LTIwSDYwdjIwSDB2LTIwYzAgLTEwLjU3IDcuNDMtMjAgMjAtMjBIMTB2ODBoODB2LTIwSDcwdjIwczEwLTEwLjU3IDEwLTIwdi0yMHptLTUwIDIwYzAgMTAuNTcgNy40MyAyMCAyMCAyMC41IDcuNDQgMCAxNS03LjU2IDE1LTE1cy03LjU2LTE1LTE1LTE1cy0xNSA3LjU2LTE1IDE1czcuNTYgMTUgMTUgMTUgMTUtNy41NiAxNS0xNXptNTAgMjBjMCAxMC41Ny03LjQzIDIwLTIwIDIwcy0yMC04LjQzLTIwLTIwIDguNDMtMjAgMjAgMjBzMjAgOC40MyAyMCAyMHoiIGZpbGw9IiNmZjY5YjQiIGZpbGwtb3BhY2l0eT0iMC4xIi8+PC9zdmc+';">
            </div>
          </div>
        `;
        
        return frame;
      };
      
      // 添加所有照片到胶卷
        photos.forEach((photo, index) => {
          const filmFrame = createFilmFrame(photo, index);
          // 为每个照片添加点击事件，实现点击爆炸弹幕效果
          const imgElement = filmFrame.querySelector('img');
          if (imgElement) {
            imgElement.addEventListener('click', (e) => {
              // 不再阻止冒泡，让照片点击也触发全局点击事件
              // 但仍然可以在这里单独处理照片点击的弹幕效果
              // 获取点击位置（相对于视口）
              const rect = imgElement.getBoundingClientRect();
              const clickX = rect.left + rect.width / 2;
              const clickY = rect.top + rect.height / 2;
              // 爆炸出弹幕
              explodeDanmuAtPosition(clickX, clickY);
            });
            // 提高照片的点击区域
            imgElement.style.cursor = 'pointer';
            imgElement.style.userSelect = 'none';
          }
          filmRoll.appendChild(filmFrame);
        });
      
      // 添加胶卷孔
      createFilmHoles(filmRoll, 'left');
      createFilmHoles(filmRoll, 'right');
      
      // 将胶卷添加到slider
      slider.appendChild(filmRoll);
      
      // 添加CSS样式
      const style = document.createElement('style');
      style.textContent = `
        /* 胶卷照片默认透明，加载后显示 */
        #photo-slider img {
          opacity: 0;
          transition: opacity 0.5s ease-in-out;
        }
        /* 胶卷外观样式 */
        .film-roll-bg {
          background: linear-gradient(90deg, #333, #666, #333);
        }
      `;
      document.head.appendChild(style);
        
        // 滑动相关变量
        let startX, moveX, currentTranslateX = 0;
        let isDragging = false;
        
        // 容器宽度
        let containerWidth = container.offsetWidth;
        // 最大可滚动距离
        let maxScrollDistance = Math.max(0, slider.offsetWidth - containerWidth);
        
        // 更新左右界限指示器
        function updateBounds() {
          leftBound.classList.toggle('hidden', currentTranslateX >= 0);
          rightBound.classList.toggle('hidden', currentTranslateX <= -maxScrollDistance);
        }
        
        // 设置translateX值，确保在边界内
        function setTranslateX(value) {
          // 限制在边界内
          if (value > 0) value = 0;
          if (value < -maxScrollDistance) value = -maxScrollDistance;
          
          currentTranslateX = value;
          slider.style.transform = `translateX(${currentTranslateX}px)`;
          updateBounds();
        }
        
        // 触摸开始事件
        container.addEventListener('touchstart', (e) => {
          startX = e.touches[0].clientX;
          isDragging = true;
          slider.style.transition = 'none'; // 移除过渡效果以便流畅拖动
        }, { passive: false });
        
        // 触摸移动事件
        container.addEventListener('touchmove', (e) => {
          if (!isDragging) return;
          e.preventDefault();
          
          moveX = e.touches[0].clientX;
          const diff = moveX - startX;
          
          // 边界弹性效果
          let newTranslateX = currentTranslateX + diff;
          if (newTranslateX > 0) {
            // 左侧边界弹性
            newTranslateX = newTranslateX * 0.5;
          } else if (newTranslateX < -maxScrollDistance) {
            // 右侧边界弹性
            newTranslateX = -maxScrollDistance + (newTranslateX + maxScrollDistance) * 0.5;
          }
          
          slider.style.transform = `translateX(${newTranslateX}px)`;
        }, { passive: false });
        
        // 触摸结束事件
        container.addEventListener('touchend', () => {
          if (!isDragging) return;
          
          const diff = moveX - startX;
          let newTranslateX = currentTranslateX + diff;
          
          // 确保在边界内
          if (newTranslateX > 0) newTranslateX = 0;
          if (newTranslateX < -maxScrollDistance) newTranslateX = -maxScrollDistance;
          
          // 平滑过渡到最终位置
          slider.style.transition = 'transform 0.3s ease';
          slider.style.transform = `translateX(${newTranslateX}px)`;
          
          currentTranslateX = newTranslateX;
          updateBounds();
          isDragging = false;
          
          // 移除过渡效果
          setTimeout(() => {
            slider.style.transition = '';
          }, 300);
        });
        
        // 鼠标拖拽事件（桌面端）
        container.addEventListener('mousedown', (e) => {
          startX = e.clientX;
          isDragging = true;
          slider.style.transition = 'none'; // 移除过渡效果以便流畅拖动
        });
        
        document.addEventListener('mousemove', (e) => {
          if (!isDragging) return;
          
          moveX = e.clientX;
          const diff = moveX - startX;
          
          // 边界弹性效果
          let newTranslateX = currentTranslateX + diff;
          if (newTranslateX > 0) {
            // 左侧边界弹性
            newTranslateX = newTranslateX * 0.5;
          } else if (newTranslateX < -maxScrollDistance) {
            // 右侧边界弹性
            newTranslateX = -maxScrollDistance + (newTranslateX + maxScrollDistance) * 0.5;
          }
          
          slider.style.transform = `translateX(${newTranslateX}px)`;
        });
        
        document.addEventListener('mouseup', () => {
          if (!isDragging) return;
          
          const diff = moveX - startX;
          let newTranslateX = currentTranslateX + diff;
          
          // 确保在边界内
          if (newTranslateX > 0) newTranslateX = 0;
          if (newTranslateX < -maxScrollDistance) newTranslateX = -maxScrollDistance;
          
          // 平滑过渡到最终位置
          slider.style.transition = 'transform 0.3s ease';
          slider.style.transform = `translateX(${newTranslateX}px)`;
          
          currentTranslateX = newTranslateX;
          updateBounds();
          isDragging = false;
          
          // 移除过渡效果
          setTimeout(() => {
            slider.style.transition = '';
          }, 300);
        });
        
        // 窗口大小变化时重新计算
        window.addEventListener('resize', () => {
          const newContainerWidth = container.offsetWidth;
          const newMaxScrollDistance = Math.max(0, slider.offsetWidth - newContainerWidth);
          
          // 调整当前位置比例
          const scrollRatio = maxScrollDistance > 0 ? currentTranslateX / maxScrollDistance : 0;
          currentTranslateX = scrollRatio * newMaxScrollDistance;
          
          // 确保在新边界内
          if (currentTranslateX > 0) currentTranslateX = 0;
          if (currentTranslateX < -newMaxScrollDistance) currentTranslateX = -newMaxScrollDistance;
          
          slider.style.transform = `translateX(${currentTranslateX}px)`;
          
          // 更新变量
          containerWidth = newContainerWidth;
          maxScrollDistance = newMaxScrollDistance;
          
          updateBounds();
        });
      
      // 初始化显示
      updateBounds();
      
      // 3秒后隐藏提示
      setTimeout(() => {
        const hint = document.getElementById('swipe-hint');
        hint.style.transition = 'opacity 0.5s';
        hint.style.opacity = '0';
        setTimeout(() => hint.remove(), 500);
      }, 3000);
    }
    
    // 在指定位置爆炸弹幕
    function explodeDanmuAtPosition(x, y) {
      // 定义四个区域的配置
      const regions = [
        {
          name: '左上',
          xOffsetRange: [-60, -20], // x偏移范围（像素）
          yOffsetRange: [-60, -20], // y偏移范围（像素）
          angleRange: [Math.PI * 1.5, Math.PI * 1.875] // 角度范围（左上区域）
        },
        {
          name: '右上',
          xOffsetRange: [20, 60],
          yOffsetRange: [-60, -20],
          angleRange: [Math.PI * 1.875, 0] // 右上区域
        },
        {
          name: '左下',
          xOffsetRange: [-60, -20],
          yOffsetRange: [20, 60],
          angleRange: [Math.PI * 1.125, Math.PI * 1.5] // 左下区域
        },
        {
          name: '右下',
          xOffsetRange: [20, 60],
          yOffsetRange: [20, 60],
          angleRange: [0, Math.PI * 0.375] // 右下区域
        }
      ];
      
      // 为每个区域生成弹幕
      regions.forEach((region, regionIndex) => {
        // 每个区域生成1-2条弹幕
        const count = Math.floor(Math.random() * 2) + 1;
        
        for (let i = 0; i < count; i++) {
          // 计算弹幕的起始位置（区域内随机）
          const xOffset = Math.random() * (region.xOffsetRange[1] - region.xOffsetRange[0]) + region.xOffsetRange[0];
          const yOffset = Math.random() * (region.yOffsetRange[1] - region.yOffsetRange[0]) + region.yOffsetRange[0];
          const startX = x + xOffset;
          const startY = y + yOffset;
          
          // 随机选择弹幕文本和大小
          const textIndex = Math.floor(Math.random() * texts.length);
          const isBig = Math.random() > 0.7;
          const danmu = createDanmu(texts[textIndex], isBig);
          
          // 设置初始位置
          danmu.style.left = `${startX}px`;
          danmu.style.top = `${startY}px`;
          danmu.style.transform = 'translate(-50%, -50%) scale(0)';
          danmu.style.opacity = '0';
          
          // 随机选择一个颜色
          const color = colors[Math.floor(Math.random() * colors.length)];
          const header = danmu.querySelector('.danmu-header');
          const content = danmu.querySelector('.danmu-content');
          
          if (header && content) {
            header.style.background = `linear-gradient(135deg, ${color} 0%, ${adjustBrightness(color, -20)} 100%)`;
            content.style.color = adjustBrightness(color, -60);
          }
          
          // 添加到body
          document.body.appendChild(danmu);
          
          // 计算移动方向和距离
          // 确保角度在有效范围内
          let angle;
          if (region.angleRange[0] <= region.angleRange[1]) {
            angle = Math.random() * (region.angleRange[1] - region.angleRange[0]) + region.angleRange[0];
          } else {
            // 处理跨过0度的范围
            const range1 = Math.PI * 2 - region.angleRange[0];
            const range2 = region.angleRange[1];
            const totalRange = range1 + range2;
            const randomPoint = Math.random() * totalRange;
            
            if (randomPoint < range1) {
              angle = region.angleRange[0] + randomPoint;
            } else {
              angle = randomPoint - range1;
            }
          }
          
          // 屏幕对角线长度作为参考距离
          const diagonal = Math.sqrt(window.innerWidth * window.innerWidth + window.innerHeight * window.innerHeight);
          const distance = diagonal * (Math.random() * 0.8 + 0.6); // 对角线长度的60%-140%
          
          // 计算终点位置
          const endX = startX + Math.cos(angle) * distance;
          const endY = startY + Math.sin(angle) * distance;
          
          // 设置动画延迟（区域间间隔200ms，区域内弹幕间隔150ms）
          const delay = regionIndex * 200 + i * 150;
          
          // 启动动画
          setTimeout(() => {
            // 第一阶段：放大出现（0.4秒）
            danmu.style.transition = 'transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275), opacity 0.4s ease';
            danmu.style.transform = 'translate(-50%, -50%) scale(1)';
            danmu.style.opacity = '1';
            
            // 第二阶段：移动（1.8-3秒）
            setTimeout(() => {
              const moveDuration = Math.random() * 1.2 + 1.8; // 1.8-3秒
              danmu.style.transition = `transform ${moveDuration}s ease-out, opacity ${moveDuration}s ease`;
              danmu.style.transform = `translate(calc(-50% + ${endX - startX}px), calc(-50% + ${endY - startY}px)) scale(1)`;
              
              // 第三阶段：消失
              setTimeout(() => {
                danmu.style.transition = 'opacity 0.8s ease';
                danmu.style.opacity = '0';
                
                // 清理元素
                setTimeout(() => {
                  if (document.body.contains(danmu)) {
                    document.body.removeChild(danmu);
                  }
                }, 800);
              }, moveDuration * 1000 - 800); // 提前800ms开始消失
            }, 400);
          }, delay);
        }
      });
    }
    
    // 辅助函数：调整颜色亮度
    function adjustBrightness(color, percent) {
      // 解析颜色
      let R = parseInt(color.substring(1, 3), 16);
      let G = parseInt(color.substring(3, 5), 16);
      let B = parseInt(color.substring(5, 7), 16);
      
      // 调整亮度
      R = Math.max(0, Math.min(255, R + percent));
      G = Math.max(0, Math.min(255, G + percent));
      B = Math.max(0, Math.min(255, B + percent));
      
      // 转换回十六进制
      return '#' + 
        Math.round(R).toString(16).padStart(2, '0') + 
        Math.round(G).toString(16).padStart(2, '0') + 
        Math.round(B).toString(16).padStart(2, '0');
      }
      
    // 创建弹幕元素
    function createDanmu(text, isBig = false) {
      const danmu = document.createElement('div');
      danmu.className = `danmu ${isBig ? 'big-danmu' : ''}`;
      
      // 创建弹幕头部
      const header = document.createElement('div');
      header.className = 'danmu-header';
      
      // 添加三个点
      for (let i = 0; i < 3; i++) {
        const dot = document.createElement('div');
        dot.className = 'danmu-dot';
        header.appendChild(dot);
      }
      
      // 添加标题
      const title = document.createElement('div');
      title.className = 'danmu-title';
      title.textContent = '爱的告白';
      header.appendChild(title);
      
      // 添加内容
      const content = document.createElement('div');
      content.className = 'danmu-content';
      content.textContent = text;
      
      // 组装弹幕
      danmu.appendChild(header);
      danmu.appendChild(content);
      
      return danmu;
      }
  </script>
</body>
</html>